// Backpack that only gives ammo for valid weapons
Class UnrealBackpack : BackpackItem replaces Backpack
{
	override Inventory CreateCopy( Actor other )
	{
		// Find every unique type of ammoitem. Give it to the player if
		// he doesn't have it already, and double its maximum capacity.
		for ( int i=0; i<AllActorClasses.Size(); i++ )
		{
			let type = (class<Ammo>)(AllActorClasses[i]);
			if ( !type || (type.GetParentClass() != 'Ammo') ) continue;
			// check that it's for a valid weapon
			bool isvalid = false;
			for ( int j=0; j<AllActorClasses.Size(); j++ )
			{
				let type2 = (class<Weapon>)(AllActorClasses[j]);
				if ( !type2 ) continue;
				let rep = GetReplacement(type2);
				if ( (rep != type2) && !(rep is "DehackedPickup") ) continue;
				readonly<Weapon> weap = GetDefaultByType(type2);
				if ( !other.player || !other.player.weapons.LocateWeapon(type2) || weap.bCheatNotWeapon ) continue;
				if ( (weap.AmmoType1 == type) || (weap.AmmoType2 == type) )
				{
					isvalid = true;
					break;
				}
			}
			if ( !isvalid ) continue;
			let ammoitem = Ammo(other.FindInventory(type));
			int amount = GetDefaultByType(type).BackpackAmount;
			// extra ammo in baby mode and nightmare mode
			if ( !bIgnoreSkill ) amount = int(amount*G_SkillPropertyFloat(SKILLP_AmmoFactor));
			if ( amount < 0 ) amount = 0;
			if ( !ammoitem )
			{
				// The player did not have the ammoitem. Add it.
				ammoitem = Ammo(Spawn(type));
				ammoitem.Amount = bDepleted?0:amount;
				if ( ammoitem.BackpackMaxAmount > ammoitem.MaxAmount )
					ammoitem.MaxAmount = ammoitem.BackpackMaxAmount;
				if ( ammoitem.Amount > ammoitem.MaxAmount )
					ammoitem.Amount = ammoitem.MaxAmount;
				ammoitem.AttachToOwner(other);
			}
			else
			{
				// The player had the ammoitem. Give some more.
				if ( ammoitem.MaxAmount < ammoitem.BackpackMaxAmount )
					ammoitem.MaxAmount = ammoitem.BackpackMaxAmount;
				if ( !bDepleted && (ammoitem.Amount < ammoitem.MaxAmount) )
				{
					ammoitem.Amount += amount;
					if ( ammoitem.Amount > ammoitem.MaxAmount )
						ammoitem.Amount = ammoitem.MaxAmount;
				}
			}
		}
		return Inventory.CreateCopy(other);
	}
	override bool HandlePickup( Inventory item )
	{
		// Since you already have a backpack, that means you already have every
		// kind of ammo in your inventory, so we don't need to look at the
		// entire PClass list to discover what kinds of ammo exist, and we don't
		// have to alter the MaxAmount either.
		if ( item is 'BackpackItem' )
		{
			for ( let probe = Owner.Inv; probe; probe = probe.Inv )
			{
				if ( probe.GetParentClass() != 'Ammo' ) continue;
				if ( probe.Amount >= probe.MaxAmount && !sv_unlimited_pickup ) continue;
				int amount = Ammo(probe).Default.BackpackAmount;
				// extra ammo in baby mode and nightmare mode
				if ( !bIgnoreSkill )
					amount = int(amount*G_SkillPropertyFloat(SKILLP_AmmoFactor));
				probe.Amount += amount;
				if ( (probe.Amount > probe.MaxAmount) && !sv_unlimited_pickup )
					probe.Amount = probe.MaxAmount;
			}
			// The pickup always succeeds, even if you didn't get anything
			item.bPickupGood = true;
			return true;
		}
		return false;
	}
	override void DoPickupSpecial( Actor toucher )
	{
		Super.DoPickupSpecial(toucher);
		if ( gameinfo.gametype&GAME_DOOMCHEX )
		{
			static const Class<Inventory> xitems[] = {"Flare", "Seeds", "SentryItem", "VoiceBox", "ForceField", "Dampener", "Peacemaker"};
			int xitemn[7];
			xitemn[0] = max(0,Random[BackpackExtra](-1,3));
			xitemn[1] = max(0,Random[BackpackExtra](-1,3));
			xitemn[2] = max(0,Random[BackpackExtra](-2,1));
			xitemn[3] = max(0,Random[BackpackExtra](-2,1));
			xitemn[4] = max(0,Random[BackpackExtra](-2,1));
			xitemn[5] = max(0,Random[BackpackExtra](-1,1));
			xitemn[6] = max(0,Random[BackpackExtra](-2,1));
			// random doubling
			if ( !Random[BackpackExtra](0,4) ) xitemn[0] *= 2;
			if ( !Random[BackpackExtra](0,4) ) xitemn[1] *= 2;
			if ( !Random[BackpackExtra](0,9) ) xitemn[2] *= 2;
			if ( !Random[BackpackExtra](0,7) ) xitemn[3] *= 2;
			if ( !Random[BackpackExtra](0,6) ) xitemn[4] *= 2;
			if ( !Random[BackpackExtra](0,5) ) xitemn[5] *= 2;
			if ( !Random[BackpackExtra](0,9) ) xitemn[6] *= 2;
			int total = 0;
			for ( int i=0; i<7; i++ ) total += xitemn[i];
			if ( total <= 0 ) return;
			String extratxt = StringTable.Localize("$I_BACKPACKEXTRA");
			for ( int i=0; i<7; i++ )
			{
				if ( xitemn[i] <= 0 ) continue;
				extratxt = extratxt..String.Format("%dx %s, ",xitemn[i],GetDefaultByType(xitems[i]).GetTag());
				toucher.GiveInventory(xitems[i],xitemn[i]);
			}
			// remove trailing comma
			extratxt.Truncate(extratxt.Length()-2);
			PrintPickupMessage(true,extratxt..".");
		}
	}
	Default
	{
		Tag "$T_BACKPACK";
		Inventory.PickupMessage "$I_BACKPACK";
		Inventory.RespawnTics 2100;
	}
	States
	{
	Spawn:
		BPAK A -1;
		Stop;
	}
}

Class UTranslator : UnrealInventory
{
	bool bCurrentlyActivated, bNewMessage, bNotNewMessage, bShowHint;
	string NewMessage, Hint;
	ui TextureID thud;
	ui Font tfnt;

	ui void DrawTranslator( Vector2 scalev, double ClipX, double ClipY )
	{
		if ( thud.IsNull() ) thud = TexMan.CheckForTexture("TranHUD3",TexMan.Type_Any);
		if ( !tfnt ) tfnt = Font.FindFont('UTahoma10');
		double CurX, CurY;
		CurX = ClipX/2-128;
		CurY = ClipY/2-68;
		Screen.DrawTexture(thud,false,CurX,CurY,DTA_VirtualWidthF,ClipX,DTA_VirtualHeightF,ClipY,DTA_KeepRatio,true);
		String ttxt;
		if ( bShowHint && (Hint.length() > 0) ) ttxt = String.Format("%s: %s",StringTable.Localize("$TR_HINT"),Hint);
		else if ( NewMessage.length() > 0 ) ttxt = NewMessage;
		else ttxt = StringTable.Localize("$TR_NOMSG");
		BrokenLines lines = tfnt.BreakLines(ttxt,220);
		int th = tfnt.GetHeight();
		CurX += 20;
		CurY += 18;
		for ( int i=0; i<lines.Count() && i<(110/th); i++ )
		{
			Screen.DrawText(tfnt,Font.CR_GREEN,CurX,CurY,lines.StringAt(i),DTA_VirtualWidthF,ClipX,DTA_VirtualHeightF,ClipY,DTA_KeepRatio,true);
			CurY += th-1;
		}
	}

	override void Travelled()
	{
		Super.Travelled();
		NewMessage = Hint = "";
	}

	override bool Use( bool pickup )
	{
		if ( pickup ) return false;
		bActive = bCurrentlyActivated = !bCurrentlyActivated;
		if ( !bActive ) bShowHint = bNewMessage = bNotNewmessage = false;
		return false;
	}

	Default
	{
		Tag "$T_TRANSLATOR";
		Inventory.PickupMessage "$I_TRANSLATOR";
		Inventory.Icon "I_Tran";
		Inventory.MaxAmount 1;
	}
}

Class VoiceBox : UnrealInventory
{
	Actor box;

	Default
	{
		Tag "$T_VOICEBOX";
		Inventory.PickupMessage "$I_VOICEBOX";
		Inventory.Icon "I_VoiceB";
		Inventory.MaxAmount 5;
		UnrealInventory.Charge 600;
	}
	override void Tick()
	{
		Super.Tick();
		if ( bActive )
		{
			if ( box ) Charge = box.ReactionTime;
			else
			{
				Charge = DefaultCharge;
				bActive = false;
				Amount--;
				if ( Amount <= 0 ) DepleteOrDestroy();
			}
		}
	}
	override bool Use( bool pickup )
	{
		if ( pickup || bActive ) return false;
		bActive = true;
		Vector3 x, y, z;
		[x, y, z] = dt_CoordUtil.GetAxes(Owner.pitch,Owner.angle,Owner.roll);
		Vector3 origin = Owner.Vec2OffsetZ(0,0,Owner.player.viewz);
		origin = level.Vec3Offset(origin,x*20.-z*8.);
		box = Spawn("VoiceBoxActive",origin);
		box.ReactionTime = Charge;
		box.vel = x*12.;
		box.vel.z += 3.;
		box.target = Owner;
		box.angle = Owner.angle;
		box.pitch = Owner.pitch;
		return false;
	}
	States
	{
	Spawn:
		VBOX A -1;
		Stop;
	}
}

Class VoiceBoxHitbox : Actor
{
	Default
	{
		Tag "$T_VOICEBOX";
		Radius 6;
		Height 9;
		Health 60;
		+SHOOTABLE;
		+NOGRAVITY;
		+NOCLIP;
		+DONTSPLASH;
		+NOBLOOD;
		+NOTELEPORT;
	}
	override void Tick()
	{
		Super.Tick();
		if ( !master )
		{
			Destroy();
			return;
		}
		SetOrigin(master.pos,true);
	}
	override void Die( Actor source, Actor inflictor, int dmgflags, Name MeansOfDeath )
	{
		if ( master ) master.ReactionTime = 0;
		Super.Die(source,inflictor,dmgflags,MeansOfDeath);
	}
}

Class VoiceBoxActive : Actor
{
	Actor b;
	bool alreadyhit;

	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		b = Spawn("VoiceBoxHitbox",pos);
		b.master = self;
	}
	action void A_VoiceBoxPlay()
	{
		static const String BattleSounds[] =
		{
			"automag/shot",
			"utrl/explode",
			"automag/shot",
			"automag/shot",
			"flak/altfire",
			"utrl/explode",
			"flak/fire",
			"shock/fire",
			"stinger/hit2",
			"automag/shot"
		};
		if ( invoker.b ) invoker.b.A_AlertMonsters(0,AMF_TARGETEMITTER);
		for ( int i=0; i<10; i++ ) if ( !Random[Voicebox](0,30) ) A_PlaySound(BattleSounds[i],CHAN_AUTO,FRandom[Voicebox](0.5,1.0));
	}
	Default
	{
		Radius 6;
		Height 6;
		PROJECTILE;
		-NOGRAVITY;
		+USEBOUNCESTATE;
		+SKYEXPLODE;
		+MOVEWITHSECTOR;
		+CANBOUNCEWATER;
		BounceType "Hexen";
		BounceFactor 0.3;
		WallBounceFactor 0.3;
		Gravity 0.35;
		ReactionTime 200;
	}
	States
	{
	Spawn:
		VBOX A -1;
		Stop;
	Bounce:
		VBOX A 0
		{
			if ( alreadyhit )
			{
				ClearBounce();
				ExplodeMissile();
			}
			else
			{
				A_SetPitch(0);
				A_PlaySound("transloc/bounce");
				if ( BlockingFloor ) alreadyhit = true;
			}
		}
		Goto Spawn;
	Death:
		VBOX A 30;
		VBOX ABCDEFGHIJ 1
		{
			A_VoiceBoxPlay();
			ReactionTime--;
			return A_JumpIf(ReactionTime<=0,"Death2");
		}
		Goto Death+1;
	Death2:
		TNT1 A 1 A_Log("// TODO explosion");
		Stop;
	}
}

Class Flare : UnrealInventory
{
}

Class LightFlare : UnrealInventory
{
}

Class DarkFlare : UnrealInventory
{
}

Class Dampener : UnrealInventory
{
	static bool Active( Actor Owner )
	{
		let d = Dampener(Owner.FindInventory("Dampener"));
		if ( d && d.bActive ) return true;
		return false;
	}
	override bool Use( bool pickup )
	{
		if ( pickup ) return false;
		bActive = !bActive;
		Owner.A_PlaySound(bActive?"dampener/on":"dampener/off",CHAN_ITEM);
		return false;
	}
	override void Tick()
	{
		Super.Tick();
		if ( !bActive ) return;
		if ( DrainCharge(1) )
		{
			Owner.A_PlaySound("dampener/off",CHAN_ITEM);
			PrintPickupMessage(true,StringTable.Localize("$D_DAMPENER"));
		}
	}
	Default
	{
		Tag "$T_DAMPENER";
		Inventory.PickupMessage "$I_DAMPENER";
		Inventory.Icon "I_Dampen";
		Inventory.MaxAmount 5;
		UnrealInventory.Charge 1000;
	}
	States
	{
	Spawn:
		DAMP A 8 A_CheckProximity(1,"PlayerPawn",80,1,CPXF_ANCESTOR|CPXF_CHECKSIGHT);
		Wait;
		DAMP ABC 8;
		DAMP DEFGHIJ 3;
		DAMP D 0 A_CheckProximity(1,"PlayerPawn",80,0,CPXF_ANCESTOR|CPXF_CHECKSIGHT|CPXF_EXACT);
		Goto Spawn+4;
		DAMP CBA 8;
		Goto Spawn;
	}
}

Class Forcefield : UnrealInventory
{
	Default
	{
		Tag "$T_FORCEFIELD";
		Inventory.PickupMessage "$I_FORCEFIELD";
		Inventory.Icon "I_ForceF";
		Inventory.MaxAmount 5;
	}
	override bool Use( bool pickup )
	{
		if ( pickup ) return false;
		Vector3 x, y, z;
		[x, y, z] = dt_CoordUtil.GetAxes(Owner.pitch,Owner.angle,Owner.roll);
		Vector3 origin = level.Vec3Offset(Owner.Vec2OffsetZ(0,0,Owner.player.viewz),x*90.);
		origin = level.Vec3Offset(origin,(0,0,-GetDefaultByType("ForceFieldEffect").Height*.5));
		if ( !level.IsPointInLevel(origin) )
		{
			PrintPickupMessage(true,StringTable.Localize("$M_FFNOROOM"));
			return false;
		}
		let a = Spawn("ForceFieldEffect",origin);
		if ( !a.TestMobjLocation() )
		{
			PrintPickupMessage(true,StringTable.Localize("$M_FFNOROOM"));
			a.Destroy();
			return false;
		}
		a.target = Owner;
		a.angle = Owner.angle;
		return true;
	}
	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		tracer = Spawn("ForcefieldX",pos);
		tracer.angle = angle;
		tracer.target = self;
	}
	States
	{
	Spawn:
		FFPK A -1;
		Stop;
	}
}

Class ForcefieldX : Actor
{
	Default
	{
		RenderStyle "Add";
		+NOGRAVITY;
		+NOCLIP;
		+DONTSPLASH;
		Radius 0.1;
		Height 0;
	}
	override void Tick()
	{
		Super.Tick();
		if ( !target )
		{
			Destroy();
			return;
		}
		Warp(target,flags:WARPF_COPYINTERPOLATION|WARPF_NOCHECKPOSITION);
		bInvisible = target.bInvisible||!target.InStateSequence(target.CurState,target.FindState("Spawn"));
	}
	States
	{
	Spawn:
		FFPK A -1 Bright;
		Stop;
	}
}

Class ForceFieldLight : DynamicLight
{
	double cdown;
	Default
	{
		DynamicLight.Type "Point";
		+DYNAMICLIGHT.ATTENUATE;
		Args 0,0,0,100;
	}
	override void Tick()
	{
		Super.Tick();
		if ( !target )
		{
			Destroy();
			return;
		}
		SetOrigin(target.Vec3Offset(0,0,target.height/2.),true);
		if ( isFrozen() ) return;
		args[LIGHT_RED] = int(255*cdown);
		args[LIGHT_BLUE] = int(255*cdown);
		if ( target.bSOLID )
		{
			cdown = min(1.,cdown+1./27);
			return;
		}
		cdown = max(0.,cdown-1./35);
		if ( cdown <= 0. ) Destroy();
	}
}

Class ForcefieldEffect : Actor
{
	double nvol;

	Default
	{
		Tag "$T_FORCEFIELD";
		RenderStyle "Add";
		+NOGRAVITY;
		+NOTELEPORT;
		+DONTSPLASH;
		+CANNOTPUSH;
		+SHOOTABLE;
		+SOLID;
		+NODAMAGE;
		+NOBLOOD;
		Mass int.max;
		Health int.max;
		Radius 15;
		Height 45;
	}
	override int DamageMobj( Actor inflictor, Actor source, int damage, Name mod, int flags, double angle )
	{
		A_PlaySound("ffield/hit",CHAN_BODY);
		return Super.DamageMobj(inflictor,source,damage,mod,flags,angle);
	}
	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		A_PlaySound("ffield/on",CHAN_ITEM);
		A_PlaySound("ffield/active",CHAN_VOICE,0.6,true);
		let tracer = Spawn("ForceFieldLight",pos);
		tracer.target = self;
	}
	States
	{
	Spawn:
		FFLD ABCDEFGHI 3 Bright;
		FFLD J 700 Bright;
		FFLD J 35 Bright
		{
			A_UnsetShootable();
			A_UnsetSolid();
		}
		FFLD A 1 Bright A_PlaySound("ffield/hit",CHAN_VOICE);
		Stop;
	}
}

Class UFlashlight : UnrealInventory
{
}

Class USearchlight : UnrealInventory
{
}

Class SentryItem : UnrealInventory
{
}

Class MinigunSentry : Actor
{
}
