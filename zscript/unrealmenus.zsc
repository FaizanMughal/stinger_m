// draws unreal-style main menu
Class ListMenuItemUnrealBg : ListMenuItem
{
	TextureID tex[3];

	void Init( ListMenuDescriptor desc, String dummy )
	{
		Super.Init(0,0);
		tex[0] = TexMan.CheckForTexture("graphics/rmetal.png",TexMan.Type_Any);
		tex[1] = TexMan.CheckForTexture("graphics/menubarr.png",TexMan.Type_Any);
		tex[2] = TexMan.CheckForTexture("graphics/unlogo.png",TexMan.Type_Any);
	}

	override void Drawer( bool selected )
	{
		double StartX = 0.5*CleanWidth_1-128;
		int num = (CleanHeight_1/512)+1;
		for ( int i=0; i<=num; i++ )
			Screen.DrawTexture(tex[0],false,StartX*CleanXFac_1,512*CleanYFac_1*i,DTA_CleanNoMove_1,true);
		Screen.DrawTexture(tex[1],false,StartX*CleanXFac_1,(CleanHeight_1-58)*CleanYFac_1,DTA_CleanNoMove_1,true,DTA_LegacyRenderStyle,STYLE_Add);
		Screen.DrawTexture(tex[2],false,StartX*CleanXFac_1,(CleanHeight_1-52)*CleanYFac_1,DTA_CleanNoMove_1,true);
	}
}

Class ListMenuItemUnrealTextItem : ListMenuItemSelectable
{
	String mText;
	Font mFont;
	int mColor;
	int mSpacing;

	void Init( ListMenuDescriptor desc, String text, String hotkey, Name child, int param = 0 )
	{
		Super.Init(desc.mXpos,desc.mYpos,desc.mLinespacing,child,param);
		mText = text;
		mFont = Font.GetFont('ULargeFont');
		mColor = Font.CR_UNTRANSLATED;
		mSpacing = desc.mLineSpacing;
		mHotkey = hotkey.GetNextCodePoint(0);
	}

	void InitDirect( double x, double y, int height, String hotkey, String text, Font font, int color, int color2, Name child, int param = 0 )
	{
		Super.Init(x,y,height,child,param);
		mText = text;
		mFont = Font.GetFont('ULargeFont');
		mColor = Font.CR_UNTRANSLATED;
		int pos = 0;
		mHotkey = hotkey.GetNextCodePoint(0);
	}

	override void Drawer( bool selected )
	{
		String str = StringTable.Localize(mText);
		let fnt = (generic_ui||!mFont.CanPrint(str))?NewSmallFont:mFont;
		double basex = floor(0.5*(CleanWidth_1-fnt.StringWidth(str)));
		double basey = floor(0.25*(CleanHeight_1-mSpacing*5));
		Screen.DrawText(fnt,(fnt==NewSmallFont)?Font.CR_GREEN:mColor,(basex+mXPos)*CleanXFac_1,(basey+mYpos)*CleanYFac_1,str,DTA_CleanNoMove_1,true,DTA_Alpha,selected?1.0:0.5);
	}

	override int GetWidth()
	{
		String str = StringTable.Localize(mText);
		let fnt = (generic_ui||!mFont.CanPrint(str))?NewSmallFont:mFont;
		return max(1,fnt.StringWidth(StringTable.Localize(mText)));
	}

	override void DrawSelector( double xofs, double yofs, TextureID tex )
	{
		// nothing
	}
}

// for hud config
Class OptionMenuItemHudType : OptionMenuItem
{
	TextureID tex[6];
	CVar mCVar;

	OptionMenuItemHudType Init( String label )
	{
		Super.Init(label,"",true);
		mCVar = CVar.FindCVar('stinger_hudmode');
		tex[0] = TexMan.CheckForTexture("graphics/Hud1.png",TexMan.Type_Any);
		tex[1] = TexMan.CheckForTexture("graphics/Hud2.png",TexMan.Type_Any);
		tex[2] = TexMan.CheckForTexture("graphics/Hud3.png",TexMan.Type_Any);
		tex[3] = TexMan.CheckForTexture("graphics/Hud4.png",TexMan.Type_Any);
		tex[4] = TexMan.CheckForTexture("graphics/Hud5.png",TexMan.Type_Any);
		tex[5] = TexMan.CheckForTexture("graphics/Hud6.png",TexMan.Type_Any);
		return self;
	}

	override bool Selectable()
	{
		return false;
	}

	override int Draw( OptionMenuDescriptor desc, int y, int indent, bool selected )
	{
		int xpos = indent + CursorSpace();
		int ypos = y + OptionMenuSettings.mLinespacing*CleanYfac_1;
		Screen.DrawFrame(xpos,ypos,64*CleanXFac_1,64*CleanYFac_1);
		Screen.DrawTexture(tex[mCVar.GetInt()],false,xpos,ypos,DTA_CleanNoMove_1,true);
		return -1;
	}
}

// because I can't change the font or color in mapinfo
Class GreenMessageBox : MessageBoxMenu
{
	override void Init( Menu parent, String message, int messagemode, bool playsound, Name cmd, voidptr native_handler )
	{
		Super.Init(parent,message,messagemode,playsound,cmd,native_handler);
		Font NFont = Font.GetFont('UMedFont');
		if ( !generic_ui )
		{
			if ( NFont && NFont.CanPrint(message) && NFont.CanPrint("$TXT_YES") && NFont.CanPrint("$TXT_NO") ) textFont = NFont;
			else if ( OriginalSmallFont && OriginalSmallFont.CanPrint(message) && OriginalSmallFont.CanPrint("$TXT_YES") && OriginalSmallFont.CanPrint("$TXT_NO") ) textFont = OriginalSmallFont;
		}
		if ( !textFont )
		{
			arrowFont = textFont = NewSmallFont;
			int factor = (CleanXfac+1)/2;
			destWidth = screen.GetWidth()/factor;
			destHeight = screen.GetHeight()/factor;
			selector = "â–¶";
		}
		else
		{
			arrowFont = ConFont;
			destWidth = CleanWidth;
			destHeight = CleanHeight;
			selector = "\xd";
		}
		int mr1 = destWidth/2+10+textFont.StringWidth(Stringtable.Localize("$TXT_YES"));
		int mr2 = destWidth/2+10+textFont.StringWidth(Stringtable.Localize("$TXT_NO"));
		mMouseRight = MAX(mr1,mr2);
		mMessage = textFont.BreakLines(Stringtable.Localize(message),generic_ui?600:300);
	}
	override void Drawer ()
	{
		int i, y;
		int fontheight = textFont.GetHeight();
		y = destHeight/2;
		int c = mMessage.Count();
		y -= c*fontHeight/2;
		for ( i=0; i<c; i++ )
		{
			screen.DrawText (textFont,Font.CR_GREEN,(destWidth/2)-mMessage.StringWidth(i)/2,y,mMessage.StringAt(i),DTA_VirtualWidth,destWidth,DTA_VirtualHeight,destHeight,DTA_KeepRatio,true);
			y += fontheight;
		}
		if ( mMessageMode == 0 )
		{
			y += fontheight;
			mMouseY = y;
			screen.DrawText(textFont,(messageSelection==0)?Font.CR_WHITE:Font.CR_DARKGREEN,destWidth/2,y,Stringtable.Localize("$TXT_YES"),DTA_VirtualWidth,destWidth,DTA_VirtualHeight,destHeight,DTA_KeepRatio,true);
			screen.DrawText(textFont,(messageSelection==1)?Font.CR_WHITE:Font.CR_DARKGREEN,destWidth/2,y+fontheight,Stringtable.Localize("$TXT_NO"),DTA_VirtualWidth,destWidth,DTA_VirtualHeight,destHeight,DTA_KeepRatio,true);
			if ( messageSelection >= 0 )
			{
				if ( (MenuTime()%8) < 6 )
				{
					screen.DrawText(arrowFont,OptionMenuSettings.mFontColorSelection,(destWidth/2)-11,y+fontheight*messageSelection,selector,DTA_VirtualWidth,destWidth,DTA_VirtualHeight,destHeight,DTA_KeepRatio,true);
				}
			}
		}
	}
}

// Translator display as a menu, allows for more interactivity
// TODO:
//  - additional mouse input options
//  - support for extended menu graphic
Class TranslatorMenu : GenericMenu
{
	bool bShowHint;
	UTranslator trns;
	TextureID thud, scroll[4];
	Font tfnt, mfnt, pfnt;
	BrokenLines lines;
	int th, startline[0], maxlines[2], entry;

	private void SetText( String txt )
	{
		String ttxt = (txt.Length()>0)?txt:StringTable.Localize("$TR_NOMSG");
		tfnt = (!mfnt.CanPrint(ttxt))?NewSmallFont:mfnt;
		lines = tfnt.BreakLines(ttxt,200);
		th = tfnt.GetHeight();
		startline[0] = 0;
		startline[1] = 0;
		maxlines[0] = 88/th;
	}

	override void Init( Menu parent )
	{
		Super.Init(parent);
		trns = UTranslator(players[consoleplayer].mo.FindInventory('UTranslator'));
		mfnt = Font.GetFont('UMedFont');
		pfnt = Font.GetFont('UOldTinyFont');
		if ( !trns || !trns.Owner || (trns.Owner.Health <= 0) )
		{
			// don't do anything, will get killed in the next tick
			return;
		}
		MenuSound("menu/activate");
		thud = TexMan.CheckForTexture("TranHUD3",TexMan.Type_Any);
		scroll[0] = TexMan.CheckForTexture("VSldT",TexMan.Type_Any);
		scroll[1] = TexMan.CheckForTexture("VSldM",TexMan.Type_Any);
		scroll[2] = TexMan.CheckForTexture("VSldB",TexMan.Type_Any);
		scroll[3] = TexMan.CheckForTexture("VSldO",TexMan.Type_Any);
		if ( StatusBar is 'UnrealHUD' )
			UnrealHUD(StatusBar).bTranslatorActive = true;
		entry = 0;
		SetText(StringTable.Localize(GetMessage(entry)));
	}

	private String GetMessage( int idx = 0 )
	{
		if ( idx == 0 ) return trns.NewMessage;
		else return trns.OldMessages[trns.OldMessages.Size()-idx];
	}

	private String GetHint( int idx = 0 )
	{
		if ( idx == 0 ) return trns.Hint;
		else return trns.OldHints[trns.OldHints.Size()-idx];
	}

	override void Ticker()
	{
		menuactive = OnNoPause;	// don't pause game while translator is active
		if ( trns && trns.Owner && (trns.Owner.Health > 0) ) return;
		if ( StatusBar is 'UnrealHUD' )
			UnrealHUD(StatusBar).bTranslatorActive = false;
		Close();
	}

	override bool OnUIEvent( UIEvent ev )
	{
		switch ( ev.type )
		{
		case UIEvent.Type_WheelUp:
			if ( startline[0] > 0 ) MenuSound("menu/cursor");
			startline[0] = max(0,startline[0]-3);
			return true;
		case UIEvent.Type_WheelDown:
			if ( startline[0] < max(0,lines.Count()-maxlines[0]) ) MenuSound("menu/cursor");
			startline[0] = min(max(0,lines.Count()-maxlines[0]),startline[0]+3);
			return true;
		}
		return Super.OnUIEvent(ev);
	}

	override bool MenuEvent( int mkey, bool fromcontroller )
	{
		switch( mkey )
		{
		case MKEY_Enter:
		case MKEY_Back:
			if ( StatusBar is 'UnrealHUD' )
				UnrealHUD(StatusBar).bTranslatorActive = false;
			MenuSound(GetCurrentMenu()?"menu/backup":"menu/clear");
			Close();
			return true;
		case MKEY_Up:
			if ( startline[0] > 0 ) MenuSound("menu/cursor");
			startline[0] = max(0,startline[0]-1);
			return true;
		case MKEY_Down:
			if ( startline[0] < max(0,lines.Count()-maxlines[0]) ) MenuSound("menu/cursor");
			startline[0] = min(max(0,lines.Count()-maxlines[0]),startline[0]+1);
			return true;
		case MKEY_PageDown:
			if ( trns && (GetHint(entry).length() > 0) )
			{
				MenuSound("menu/cursor");
				bShowHint = true;
				SetText(StringTable.Localize(GetHint(entry)));
			}
			return true;
		case MKEY_PageUp:
			if ( trns && bShowHint )
			{
				MenuSound("menu/cursor");
				bShowHint = false;
				SetText(StringTable.Localize(GetMessage(entry)));
			}
			return true;
		case MKEY_Left:
			if ( trns && (entry < trns.OldMessages.Size()) )
			{
				MenuSound("menu/cursor");
				bShowHint = false;
				entry++;
				SetText(StringTable.Localize(GetMessage(entry)));
			}
			return true;
		case MKEY_Right:
			if ( trns && (entry > 0) )
			{
				MenuSound("menu/cursor");
				bShowHint = false;
				entry--;
				SetText(StringTable.Localize(GetMessage(entry)));
			}
			return true;
		}
		return false;
	}

	override void Drawer()
	{
		Super.Drawer();
		if ( trns && trns.Owner && (trns.Owner.Health > 0) ) return;
		double ClipX, ClipY, CurX, CurY;
		if ( StatusBar is 'UnrealHUD' )
		{
			ClipX = UnrealHUD(StatusBar).ClipX;
			ClipY = UnrealHUD(StatusBar).ClipY;
		}
		else
		{
			ClipX = CleanWidth_1;
			ClipY = CleanHeight_1;
		}
		// The translator
		CurX = ClipX/2-128;
		CurY = ClipY/2-68;
		Screen.DrawTexture(thud,false,CurX,CurY,DTA_VirtualWidthF,ClipX,DTA_VirtualHeightF,ClipY,DTA_KeepRatio,true);
		// The message text
		CurX += 22;
		CurY += 22;
		int l = startline[0];
		for ( int i=0; i<maxlines[0]; i++ )
		{
			if ( l >= lines.Count() ) break;
			Screen.DrawText(tfnt,Font.CR_UNTRANSLATED,CurX,CurY,lines.StringAt(l),DTA_VirtualWidthF,ClipX,DTA_VirtualHeightF,ClipY,DTA_KeepRatio,true);
			l++;
			CurY += th;
		}
		// Scrollbar
		CurX = ClipX/2+100;
		if ( lines.Count() > maxlines[0] )
		{
			CurY = ClipY/2-54;
			Screen.DrawTexture(scroll[0],false,CurX,CurY,DTA_VirtualWidthF,ClipX,DTA_VirtualHeightF,ClipY,DTA_KeepRatio,true);
			CurY += 8;
			for ( int i=0; i<10; i++ )
			{
				Screen.DrawTexture(scroll[1],false,CurX,CurY,DTA_VirtualWidthF,ClipX,DTA_VirtualHeightF,ClipY,DTA_KeepRatio,true);
				CurY += 8;
			}
			Screen.DrawTexture(scroll[2],false,CurX,CurY,DTA_VirtualWidthF,ClipX,DTA_VirtualHeightF,ClipY,DTA_KeepRatio,true);
			CurY = (ClipY/2-46) + ((startline[0]*72)/max(1,lines.Count()-maxlines[0]));
			Screen.DrawTexture(scroll[3],false,CurX,CurY,DTA_VirtualWidthF,ClipX,DTA_VirtualHeightF,ClipY,DTA_KeepRatio,true);
		}
		if ( !bShowHint && (GetHint(entry).length() > 0) )
		{
			CurY = ClipY/2+40;
			Screen.DrawText(pfnt,Font.CR_GREEN,CurX,CurY,">>",DTA_VirtualWidthF,ClipX,DTA_VirtualHeightF,ClipY,DTA_KeepRatio,true,DTA_Alpha,(gametic%16)/16.);
		}
		CurX = ClipX/2-106;
		CurY = ClipY/2+40;
		if ( bShowHint ) Screen.DrawText(pfnt,Font.CR_GREEN,CurX,CurY,"<<",DTA_VirtualWidthF,ClipX,DTA_VirtualHeightF,ClipY,DTA_KeepRatio,true,DTA_Alpha,(gametic%16)/16.);
		else if ( trns.OldMessages.Size() > 0 ) Screen.DrawText(pfnt,Font.CR_GREEN,CurX,CurY,String.Format("%s %d / %d %s",(entry<trns.OldMessages.Size())?"<":" ",trns.OldMessages.Size()+1-entry,trns.OldMessages.Size()+1,(entry>0)?">":" "),DTA_VirtualWidthF,ClipX,DTA_VirtualHeightF,ClipY,DTA_KeepRatio,true);
	}
}
